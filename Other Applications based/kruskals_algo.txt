Given a weighted, undirected and connected graph of V vertices and E edges. 
The task is to find the sum of weights of the edges of the Minimum Spanning Tree.

struct node{
    int weight;
    int s1;
    int s2;
};

struct cmpweight{
    bool operator()(struct node &a,struct node &b){ //true-swap false-no swap
        return a.weight>b.weight;
    }  
};
class Solution
{
	public:
	priority_queue<node,vector<node>,cmpweight> Q;
	
	 bool helper(int v,vector<int> &visited, vector<int> adj[],int parent){
        
        visited[v]=0; //pushed in stack
        
        for(auto l:adj[v]){
            if(visited[l]==0 && l!=parent){ //l!=parent is right not l!=v check in point of adajacency list
                return true;
            }
            else if(visited[l]==-1){
                if(helper(l,visited,adj,v)) //not return helper() make if and then return 
                    return true;
                //visited[l]=1; //popped out from stack    //uniformity
            }
            else{ //visited[l]==1
                continue;
            }
        } 
        
        return false;
    }
    
	bool isCycle(int V, vector<int>adj[])
	{
	    vector<int> visited(V,-1);
	    for(int i=0;i<V;i++){ //since many dfs graphs
	        if(visited[i]==-1){
	            if(helper(i,visited,adj,-1))
	                return true;
	            //visited[i]=1;     //uniformity.
	        }
	    }
	    
	    return false;
	}
	
	//Function to find sum of weights of edges of the Minimum Spanning Tree.
    int spanningTree(int V, vector<vector<int>> adj[])
    {
        vector<int> mintree[V];
        int res=0;
        for(int i=0;i<V;i++){ //add all edges to heaps
            for(auto x:adj[i]){ //x[0]-vertex number //x[1]-weight
                node temp;
                temp.weight=x[1];
                temp.s1=i;
                temp.s2=x[0];
                Q.push(temp);
            }
        } //edges pushed
        
        for(int i=1;i<=(V-1);){ //select v-1 edges
            //if(Q.empty())
              //  break;
            struct node minedge=Q.top();
            mintree[minedge.s1].push_back(minedge.s2);
            mintree[minedge.s2].push_back(minedge.s1);
            if(isCycle(V,mintree)){ //need to remove added connections
                mintree[minedge.s1].pop_back();
                mintree[minedge.s2].pop_back();
            }
            else{
                res+=minedge.weight;
                i++;
                //cout<<"res:"<<res<<endl;
            }
            //cout<<minedge.s1<<" "<<minedge.s2<<" "<<minedge.weight<<endl;
            Q.pop();
        }
        
        return res;
    }
	};