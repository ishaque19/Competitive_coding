INFIX TO POSTFIX

int precedence(char x){ //function to get precedence of operators
    if(x==')')
        return 4;
    else if(x=='^')
        return 3;
    else if(x=='*' || x=='/')
        return 2;
    else if(x=='+' || x=='-')
        return 1;
    else if(x=='(')
        return 0;
    else
        cout<<"Invalid Operator"<<endl;
}

class Solution
{
    public:
    stack<char> S; 
    string res="";
    //Function to convert an infix expression to a postfix expression.
    string infixToPostfix(string s)
    {
        for(auto x:s){
            if(x>='A' && x<='Z' || x>='a' && x<='z'){
                res+=x;
            } //operand
            else if(x=='('){
                S.push(x);
            }
            else if(x==')'){ //most highest precedence
                while(!S.empty() && S.top()!='('){
                    res+=S.top();
                    S.pop();
                }
                if(!S.empty())
                    S.pop(); //'(' pop out
            }
            else{ //possibilities of operators
                if(S.empty()){
                    S.push(x);
                }
                else{
                if(!S.empty() && precedence(S.top())<precedence(x)){
                    S.push(x);
                }
                else if(!S.empty() && precedence(S.top())>precedence(x)) {
                    while(!S.empty() && precedence(S.top())>precedence(x)){
                        res+=S.top();
                        S.pop();
                    }
                    if(!S.empty() && precedence(S.top())<precedence(x))
                        S.push(x);
                    else{
                        if(x=='^'){
                            S.push(x);
                        }
                        else{
                            if(!S.empty()){
                                res+=S.top();
                                S.pop();
                            }
                            S.push(x);
                        }
                    } //equal
                    
                        
                }
                
                else{ //equal //apply associativity rules
                    if(x=='^'){
                        S.push(x);
                    }
                    else{
                        if(!S.empty()){
                            res+=S.top();
                            S.pop();
                        }
                        S.push(x);
                    }
                }
                }   
            }
        }
        
        while(!S.empty()){
            res+=S.top();
            S.pop();
        }
        
        return res;
    }
};