You are given an m x n grid where each cell can have one of three values:

0 representing an empty cell,
1 representing a fresh orange, or
2 representing a rotten orange.
Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.

struct node{
    int row;
    int col;
    int time;
};
class Solution {
public:
    queue<node *> track;
    int res=-1;
    int flag;
    int orangesRotting(vector<vector<int>>& grid) {
        int total=grid.size()*grid[0].size();
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[i].size();j++){
                flag=0;
                if(grid[i][j]==2){
                    struct node *x=new node();
                    x->row=i;x->col=j;x->time=0;
                    track.push(x);   
                }
                else if(grid[i][j]==0){
                    total--;
                }
                else if(grid[i][j]==1){
                    if(i-1>=0 && i-1<grid.size()){
                        if(grid[i-1][j]==0)//(i-1,j)(i+1,j)(i,j-1)(i,j+1)
                            flag++;
                    }
                    else{
                        flag++;
                    }
                    if(i+1>=0 && i+1<grid.size()){
                        if(grid[i+1][j]==0)//(i-1,j)(i+1,j)(i,j-1)(i,j+1)
                            flag++;
                    }
                    else{
                        flag++;
                    }
                    if(j-1>=0 && j-1<grid[i].size()){
                        if(grid[i][j-1]==0)//(i-1,j)(i+1,j)(i,j-1)(i,j+1)
                            flag++;
                    }
                    else{
                        flag++;
                    }
                    if(j+1>=0 && j+1<grid[i].size()){
                        if(grid[i][j+1]==0)//(i-1,j)(i+1,j)(i,j-1)(i,j+1)
                            flag++;
                    }
                    else{
                        flag++;
                    }
                      
                    if(flag==4)
                        return res;
                }   
                else{}
            }
        }
        if(total==0)
            return 0;
        
        //need to get the last one node before emptying, whose time sequence
        while(!track.empty()){ 
            node *x=track.front();
            int i=x->row;
            int j=x->col;
            int k=x->time;
            if(i-1>=0 && i-1<grid.size()){
                if(grid[i-1][j]==1){
                    grid[i-1][j]=2;
                    struct node *temp=new node();
                    temp->row=i-1;
                    temp->col=j;
                    temp->time=k+1;
                    track.push(temp);
                }
            }
            
            if(i+1>=0 && i+1<grid.size()){
                if(grid[i+1][j]==1){
                    grid[i+1][j]=2;
                    struct node *temp=new node();
                    temp->row=i+1;
                    temp->col=j;
                    temp->time=k+1;
                    track.push(temp);
                }
            }
            
            if(j-1>=0 && j-1<grid[i].size()){
                if(grid[i][j-1]==1){
                    grid[i][j-1]=2;
                    struct node *temp=new node();
                    temp->row=i;
                    temp->col=j-1;
                    temp->time=k+1;
                    track.push(temp);
                }
            }
            
            if(j+1>=0 && j+1<grid[i].size()){
                if(grid[i][j+1]==1){
                    grid[i][j+1]=2;
                    struct node *temp=new node();
                    temp->row=i;
                    temp->col=j+1;
                    temp->time=k+1;
                    track.push(temp);
                }
            }
            
            if(track.size()==1){
                res=(track.front())->time;
            }
            track.pop();
            
        }
        
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[i].size();j++){
                if(grid[i][j]==1)
                    return  -1;
            }
        }
        
        return res;
        
        
    }
};