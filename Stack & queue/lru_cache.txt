
Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

Implement the LRUCache class:

LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
int get(int key) Return the value of the key if the key exists, otherwise return -1.
void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. 
If the number of keys exceeds the capacity from this operation, evict the least recently used key.

private:
    // A doubly linked list node which consists of prev and next values
    struct DLNode
    {
        int key;
        int value;
        DLNode *prev;
        DLNode *next;
    };

    DLNode *head;
    DLNode *tail;
    int capacity;
    unordered_map<int, DLNode *> cache;

    // adding the new node always after the head
    void addNode(DLNode *node)
    {
        node->prev = head;
        node->next = head->next;
        node->next->prev = node;
        head->next->prev = node;
        head->next = node;
    }

    // removing the node from DLL
    void removeNode(DLNode *node)
    {
        if (node->prev)
            node->prev->next = node->next;
        if (node->next)
            node->next->prev = node->prev;
    }
    // move the node from any position to dummy head's next
    void moveToHead(DLNode *node)
    {
        removeNode(node);
        addNode(node);
    }
    // pop the original tail. its the node previous to the dummy tail
    DLNode *popTail()
    {
        DLNode *originalTail = tail->prev;
        removeNode(originalTail);
        return originalTail;
    }

public:
    LRUCache(int capacity)
    {
        this->capacity = capacity;
        head = new DLNode(); //dummy head
        tail = new DLNode(); // dummy tail
        head->prev = nullptr;
        head->next = tail;
        tail->prev = head;
        tail->next = nullptr;
    }

    int get(int key)
    {
        // if key is present, renew the DLL and return the value
        if (cache.find(key) != cache.end())
        {
            moveToHead(cache[key]);
            return cache[key]->value;
        }
        return -1;
    }

    void put(int key, int value)
    {
        if (cache.find(key) != cache.end())
        {
            // key found, update the value
            cache[key]->value = value;
            moveToHead(cache[key]);
        }
        else
        {
            // node not found
            // add the new key to cache and update head of DLL

            DLNode *newNode = new DLNode();
            newNode->key = key;
            newNode->value = value;
            moveToHead(newNode);
            cache[key] = newNode; //placing new node inside cache

            if (cache.size() > capacity)
            {
                DLNode *tailNode = popTail();
                cache.erase(tailNode->key);
            }
        }
    }
};