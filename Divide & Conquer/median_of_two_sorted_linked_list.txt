Sum of middle two elements in sorted array.

 int findMidSum(int ar1[], int ar2[], int n) {
            // code here
            int start=0;
            int end=n-1;
            if(n==1)
                return ar1[0]+ar2[0];
            while(start<=end){
                int partitionX=floor((start+end)/2);
                int partitionY=(floor((n+n+1)/2))-partitionX;
                
                int leftminx,leftminy,rightmaxx,rightmaxy;
                
               /*leftminx=partitionX-1<0?INT_MIN:ar1[partitionX-1];
               leftminy=partitionY-1<0?INT_MIN:ar2[partitionY-1];
               rightmaxx=partitionX==n?INT_MAX:ar1[partitionX];
               rightmaxy=partitionY==n?INT_MAX:ar2[partitionY];  */  
                
                if(partitionX-1>=0 && partitionX-1<n){
                    leftminx=ar1[partitionX-1];
                }
                else{
                    leftminx=INT_MIN;    
                }
                
                if(partitionY-1>=0 && partitionY-1<n)
                    leftminy=ar2[partitionY-1];
                else
                    leftminy=INT_MIN;
                
                if(partitionX>=0 && partitionX<n)
                    rightmaxx=ar1[partitionX];
                else
                    rightmaxx=INT_MAX;
                    
                rightmaxy=(partitionY>=0 && partitionY<n)?ar2[partitionY]:INT_MAX ;
                
                
                //cout<<leftminx<<" "<<leftminy<<" "<<rightmaxx<<" "<<rightmaxy<<endl;
                if(leftminx<=rightmaxy && leftminy<=rightmaxx){
                    //found
                    return max(leftminx,leftminy)+min(rightmaxx,rightmaxy);
                }
                else if(leftminx>rightmaxy){
                    //move towards left in x
                    end=partitionX-1;
                }
                else{
                    //move towards right in x
                    start=partitionX+1;
                }
            }
    }
};
--------------------------------------------------------------------------
Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).

class Solution {
public:
    double divider=(double)2;
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if(nums1.size()==0 && nums2.size()!=0){
            if(nums2.size()==1)
                return nums2[0];
            else if(nums2.size()%2==0){
                int x=nums2.size()/2;
                int y=x-1;
                return (((double)nums2[x]+nums2[y])/(double)2);
            }
            else{
                int x=nums2.size()/2;
                return nums2[x]; 
            }
        }
        if(nums2.size()==0 && nums1.size()!=0){
            return findMedianSortedArrays(nums2,nums1);
        }
        if(nums2.size()==2 && nums1.size()==2){
            double sum=max(nums1[0],nums2[0])+min(nums1[1],nums2[1]);
            return sum/(double)2;
        }
        if(nums1.size()==2 && nums2.size()==1){
            if(nums2[0]<nums1[0]){
                return nums1[0];
            }
            else if(nums2[0]>nums1[1]){
                return nums1[1];
            }
            else{
                return nums2[0];
            }
        }
        if(nums2.size()==2 && nums1.size()==1){
            return findMedianSortedArrays(nums2,nums1);
        }
        if(nums1.size()==1 && nums2.size()==1){
            double sum=nums1[0]+nums2[0];
            return sum/double(2);
        }
        int size1=nums1.size();
        int size2=nums2.size();
        
        int minleftx=(size1-1)/2;
        int minlefty=(size2-1)/2;
        int maxrightx=-1;
        int maxrighty=-1;
        if(minleftx+1<size1)
            maxrightx=minleftx+1;
        if(minlefty+1<size2)
            maxrighty=minlefty+1;
      
        while(true){
            cout<<minleftx<<" "<<minlefty<<" "<<maxrightx<<" "<<maxrighty<<endl;
        
            if(nums1[minleftx]<=nums2[maxrighty] && nums2[minlefty]<=nums1[maxrightx]){
                //found
                if((size1+size2)%2==0){
                    double sum=max(nums1[minleftx],nums2[minlefty])+min(nums1[maxrightx],nums2[maxrighty]);
                    return sum/(double)2;
                }
                else{
                    return max(nums1[minleftx],nums2[minlefty]);
                }
            }
            else if(nums1[minleftx]>nums2[maxrighty]){
                minleftx--;
                maxrightx=minleftx+1;
                minlefty++;
                maxrighty=minlefty+1;
            }
            else if(nums2[minlefty]>nums1[maxrightx]){
                minlefty--;
                maxrighty=minlefty+1;
                minleftx++;
                maxrightx=minleftx+1;
            }
            else{
                
            }
        }
    }
};

-------------------------------------------------------------------------------------------------------------------------
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size();
        int n2 = nums2.size();
        // make sure first array is of smaller length i.e n1 < n2
        if(n1 > n2) return findMedianSortedArrays(nums2, nums1);
        int low = 0;
        int high = n1;
        while(low <= high)
        {
            int mid1 = (low + high) / 2;
            // works for both odd and even lengths
            int mid2 = (n1 + n2 + 1) / 2 - mid1;
            // we create two search spaces for applying binary search. left half and right half have elements 
            // from both the arrays. left1 & right1 have elements from nums1 and  left2 & right2 have elements from nums2
            // left half should be smaller than right half
            // l1 is max of left1 list, l2 is max of left2 list
            // r1 is min of right1 list, r2 is min of right2 list
            int l1 = (mid1 - 1 < 0) ? INT_MIN : nums1[mid1 - 1];
            int l2 = (mid2 - 1 < 0) ? INT_MIN : nums2[mid2 - 1];
            int r1 = (mid1 == n1) ? INT_MAX : nums1[mid1];
            int r2 = (mid2 == n2) ? INT_MAX : nums2[mid2];
            // correct partioning
            if(l1 <= r2 && l2 <= r1)
            {
                // even length -> two medians -> return average of both
                if((n1 + n2) % 2 == 0) return (max(l1, l2) + min(r1, r2)) / 2.0;
                // odd length -> one median -> return it
                else return max(l1, l2);  
            }
            if(l1 > r2)
            {
                high = mid1 - 1;
            }
            if(l2 > r1)
            {
                low = mid1 + 1;
            }
        }
        return 0.0;
    }
};
};